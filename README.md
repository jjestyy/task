== Описание задачи

Необходимо написать функцию, которая на основе двух файлов json получает третий по заданному алгоритму.

Общий смысл заключается в том, что при сохранении json-файла мы проверяем старые значения и в зависимости от метки разрешений берем элемент либо из старого файла, либо из нового.

=== Пример

Например, в документе два элемента (Элемент 1 и Элемент 2).

Пользователь не имеет права менять элемент 1, но изменил его. Однако он имеет право изменить элемент 2 и также изменил его.

В момент сохранения мы берем значение элемента 1 из старого файла, а элемента 2 из нового.

Делается это при помощи мандатной битовой метки.

В данном случае ситуацияю может бысть следующий.

Элемент 1 имеет метку 10 (первый бит выставлен)

Элемент 2 имеет метку 01 (второй бит выставлен)

Пользователь также имеет мандатную метку. Если хоть в одном бите метка совпадает, то пользователь имеет разрешение на изменение элемента.

Например, если у пользователя метка 11, то он имеет право менять оба элемента.

Если у пользователь метка 00, то он не имеет прав ни на один элемент.

Если у него метка 01, то он имеет право менять второй элемент.

В нашей задаче метка состоит из 32 бит. Для удобства мы отделяем каждые четыре бита пробелами.

=== Алгоритм работы

Для работы с json необходимо использовать библиотеку JsonObject.

Функция на входе требует 4 параметра:

1. Спецификация (строка) -- пример в файле spec.json
2. Json 1 (строка) -- пример в файле old.json
3. Json 2 (строка) -- пример в файле new.json
4. Метка (строка)

На выходе -- json, который требуется сохранить.

Работаем мы только с первым уровнем элементов раздела data.

Предпололижм в качестве метки безопасности пришли все 0 ("0000 0000 0000 0000 0000 0000 0000 0000"). Т.е. пользователю ничего нельзя

Перибираем все элементы внутри параметра data:

* opisaniye_vzaimodejstviya -- в спецификации area для данного элемента не указан, значит берём из нового файла
* state -- в спецификации area для данного элемента не указан, значит берём из нового файла
* target_transition -- в спецификации area для данного элемента не указан, значит берём из Json 2
* item_1 -- area указан, но нет ни одного совпадения, поэтому берём из Json 1
* item_2 -- area указан, но нет ни одного совпадения, поэтому берём из Json 1
* list_1 -- area указан, но нет ни одного совпадения, поэтому берём из Json 1

Предпололижм в качестве метки безопасности пришла ("1000 0000 0000 0000 0000 0000 0000 0000"). 

Перебираем все элементы data:

* opisaniye_vzaimodejstviya -- в спецификации area для данного элемента не указан, значит берём из нового файла
* state -- в спецификации area для данного элемента не указан, значит берём из нового файла
* target_transition -- в спецификации area для данного элемента не указан, значит берём из Json 2
* item_1 -- area указан, и первый бит совпадает как в метке элемента, так и в метке пользователя, поэтому берем из Json 2
* item_2 -- area указан, но нет ни одного совпадения (у пользователя выставлен первый бит, у элемента -- второй), поэтому берём из Json 1
* list_1 -- area указан, и первый бит совпадает как в метке элемента, так и в метке пользователя, поэтому берем из Json 2

Обратите внимание, что элемент может быть специфицирован через item (для словарей) или через list (для массивов). Но идентификаторы повторяться не могут, поэтому можно вначале просто просканировать спецификацию 

section -> list (код в list_id) -> group -> item (код в item_id) и составить словарь: код элемента -> area

Обязательно наличие теста.
